<!-- livebook:{"persist_outputs":true} -->

# aoc2022

## Day 1

```elixir
calories =
  "/Users/clark/code/aoc2022/inputs/1.txt"
  |> File.stream!()
  |> Enum.reduce({0, []}, fn line, {this_elf_calories, all_elf_calories} ->
    line = String.trim(line)

    if line == "" do
      {0, [this_elf_calories | all_elf_calories]}
    else
      {calories, _} = Integer.parse(line)
      {calories + this_elf_calories, all_elf_calories}
    end
  end)
  # the last 
  |> then(fn {remaining, all_elf_calories} -> [remaining | all_elf_calories] end)
  |> Enum.sort()
  |> Enum.reverse()
```

<!-- livebook:{"output":true} -->

```
[68442, 68218, 68177, 66575, 66355, 64717, 64543, 64252, 63315, 62797, 60691, 59873, 59757, 59627,
 59552, 59525, 59323, 58995, 58798, 58756, 58563, 58519, 58429, 58213, 58156, 58072, 57804, 57638,
 57629, 57570, 57541, 57333, 57174, 57053, 57034, 57028, 57023, 56891, 56831, 56790, 56492, 56414,
 56307, 56268, 56149, 56084, 55959, 55911, 55651, 55638, ...]
```

```elixir
# Star 1
[most_calories | _] = calories
68442 = most_calories
```

<!-- livebook:{"output":true} -->

```
68442
```

```elixir
# Star 2
204_837 =
  calories
  |> Enum.take(3)
  |> Enum.sum()
```

<!-- livebook:{"output":true} -->

```
204837
```

## Day 2

```elixir
win_points = 6
draw_points = 3
loss_points = 0
rock_points = 1
paper_points = 2
scissors_points = 3
```

<!-- livebook:{"output":true} -->

```
3
```

```elixir
lines =
  "/Users/clark/code/aoc2022/inputs/2.txt"
  |> File.stream!()
  |> Stream.map(fn line -> String.trim(line) end)
  |> Stream.map(fn line -> String.split(line) end)
```

<!-- livebook:{"output":true} -->

```
#Stream<[
  enum: %File.Stream{
    path: "/Users/clark/code/aoc2022/inputs/2.txt",
    modes: [:raw, :read_ahead, :binary],
    line_or_bytes: :line,
    raw: true
  },
  funs: [#Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>]
]>
```

```elixir
scores =
  lines
  |> Stream.map(fn plays ->
    Enum.map(plays, fn play ->
      case play do
        play when play in ["A", "X"] -> :rock
        play when play in ["B", "Y"] -> :paper
        play when play in ["C", "Z"] -> :scissors
      end
    end)
  end)
  |> Stream.map(fn
    [:rock, :rock] -> draw_points + rock_points
    [:rock, :paper] -> win_points + paper_points
    [:rock, :scissors] -> loss_points + scissors_points
    [:paper, :rock] -> loss_points + rock_points
    [:paper, :paper] -> draw_points + paper_points
    [:paper, :scissors] -> win_points + scissors_points
    [:scissors, :rock] -> win_points + rock_points
    [:scissors, :paper] -> loss_points + paper_points
    [:scissors, :scissors] -> draw_points + scissors_points
  end)
```

<!-- livebook:{"output":true} -->

```
#Stream<[
  enum: %File.Stream{
    path: "/Users/clark/code/aoc2022/inputs/2.txt",
    modes: [:raw, :read_ahead, :binary],
    line_or_bytes: :line,
    raw: true
  },
  funs: [#Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>,
   #Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>]
]>
```

```elixir
# Star 1
15422 = Enum.sum(scores)
```

<!-- livebook:{"output":true} -->

```
15422
```

```elixir
scores =
  lines
  |> Stream.map(fn plays ->
    Enum.map(plays, fn play ->
      case play do
        "A" -> :rock
        "B" -> :paper
        "C" -> :scissors
        "X" -> :loss
        "Y" -> :draw
        "Z" -> :win
      end
    end)
  end)
  |> Stream.map(fn
    [:rock, :win] -> win_points + paper_points
    [:rock, :draw] -> draw_points + rock_points
    [:rock, :loss] -> loss_points + scissors_points
    [:paper, :win] -> win_points + scissors_points
    [:paper, :draw] -> draw_points + paper_points
    [:paper, :loss] -> loss_points + rock_points
    [:scissors, :win] -> win_points + rock_points
    [:scissors, :draw] -> draw_points + scissors_points
    [:scissors, :loss] -> loss_points + paper_points
  end)
```

<!-- livebook:{"output":true} -->

```
#Stream<[
  enum: %File.Stream{
    path: "/Users/clark/code/aoc2022/inputs/2.txt",
    modes: [:raw, :read_ahead, :binary],
    line_or_bytes: :line,
    raw: true
  },
  funs: [#Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>,
   #Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>]
]>
```

```elixir
# Star 2
15442 = Enum.sum(scores)
```

<!-- livebook:{"output":true} -->

```
15442
```

## Day 3

```elixir
lower_az =
  97..122
  |> Enum.map(fn i -> {to_string([i]), i - 96} end)
  |> Enum.into(%{})

upper_az =
  65..90
  |> Enum.map(fn i -> {to_string([i]), i - 38} end)
  |> Enum.into(%{})

priorities = Map.merge(lower_az, upper_az)
```

<!-- livebook:{"output":true} -->

```
%{
  "W" => 49,
  "X" => 50,
  "k" => 11,
  "w" => 23,
  "G" => 33,
  "D" => 30,
  "Q" => 43,
  "K" => 37,
  "F" => 32,
  "C" => 29,
  "i" => 9,
  "v" => 22,
  "q" => 17,
  "g" => 7,
  "e" => 5,
  "c" => 3,
  "T" => 46,
  "Y" => 51,
  "V" => 48,
  "l" => 12,
  "J" => 36,
  "U" => 47,
  "B" => 28,
  "z" => 26,
  "a" => 1,
  "p" => 16,
  "f" => 6,
  "h" => 8,
  "r" => 18,
  "L" => 38,
  "S" => 45,
  "O" => 41,
  "R" => 44,
  "j" => 10,
  "o" => 15,
  "H" => 34,
  "E" => 31,
  "u" => 21,
  "s" => 19,
  "n" => 14,
  "b" => 2,
  "Z" => 52,
  "N" => 40,
  "A" => 27,
  "y" => 25,
  "M" => 39,
  "t" => 20,
  "m" => 13,
  "I" => 35,
  "P" => 42,
  ...
}
```

```elixir
input = File.stream!("/Users/clark/code/aoc2022/inputs/3.txt")
```

<!-- livebook:{"output":true} -->

```
%File.Stream{
  path: "/Users/clark/code/aoc2022/inputs/3.txt",
  modes: [:raw, :read_ahead, :binary],
  line_or_bytes: :line,
  raw: true
}
```

```elixir
both =
  input
  |> Stream.map(fn line -> String.trim(line) end)
  |> Stream.map(fn line ->
    length = String.length(line)
    half = (length / 2) |> Kernel.trunc()
    {left, right} = String.split_at(line, half)
    {left, right}
  end)
  |> Stream.map(fn {left, right} ->
    left = String.graphemes(left) |> MapSet.new()
    right = String.graphemes(right) |> MapSet.new()
    MapSet.intersection(left, right)
  end)
  |> Stream.map(fn set ->
    set
    |> Enum.map(fn item ->
      Map.fetch!(priorities, item)
    end)
    |> List.first()
  end)
```

<!-- livebook:{"output":true} -->

```
#Stream<[
  enum: %File.Stream{
    path: "/Users/clark/code/aoc2022/inputs/3.txt",
    modes: [:raw, :read_ahead, :binary],
    line_or_bytes: :line,
    raw: true
  },
  funs: [#Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>,
   #Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>]
]>
```

```elixir
# Star 1
8252 = Enum.sum(both)
```

<!-- livebook:{"output":true} -->

```
8252
```

```elixir
overlapping_three =
  input
  |> Stream.map(fn line -> String.trim(line) end)
  |> Stream.chunk_every(3)
  |> Stream.map(fn chunk ->
    Enum.map(chunk, fn line ->
      line
      |> String.graphemes()
      |> MapSet.new()
    end)
  end)
  |> Stream.map(fn sets ->
    Enum.reduce(sets, fn set, acc ->
      MapSet.intersection(set, acc)
    end)
  end)
  |> Stream.map(fn set ->
    set
    |> Enum.map(fn item ->
      Map.fetch!(priorities, item)
    end)
    |> List.first()
  end)
```

<!-- livebook:{"output":true} -->

```
#Stream<[
  enum: #Stream<[
    enum: %File.Stream{
      path: "/Users/clark/code/aoc2022/inputs/3.txt",
      modes: [:raw, :read_ahead, :binary],
      line_or_bytes: :line,
      raw: true
    },
    funs: [#Function<48.124013645/1 in Stream.map/2>,
     #Function<3.124013645/1 in Stream.chunk_while/4>]
  ]>,
  funs: [#Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>,
   #Function<48.124013645/1 in Stream.map/2>]
]>
```

```elixir
2828 = Enum.sum(overlapping_three)
```

<!-- livebook:{"output":true} -->

```
2828
```

## Day 4

```elixir
day4_input =
  "/Users/clark/code/aoc2022/inputs/4.txt"
  |> File.stream!()
  |> Stream.map(fn line -> String.trim(line) end)
  |> Stream.map(fn line ->
    String.split(line, ",")
  end)
  |> Stream.map(fn ranges ->
    Enum.map(ranges, fn range ->
      range
      |> String.split("-")
      |> Enum.map(fn i ->
        i
        |> Integer.parse()
        |> then(fn {i, _} -> i end)
      end)
    end)
  end)

# day4_input =
#    "2-4,6-8\n2-3,4-5\n5-7,7-9\n2-8,3-7\n6-6,4-6\n2-6,4-8"
#    |> String.split()
```

<!-- livebook:{"output":true} -->

```
#Stream<[
  enum: %File.Stream{
    path: "/Users/clark/code/aoc2022/inputs/4.txt",
    modes: [:raw, :read_ahead, :binary],
    line_or_bytes: :line,
    raw: true
  },
  funs: [#Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>,
   #Function<48.124013645/1 in Stream.map/2>]
]>
```

```elixir
day4_star1 =
  day4_input
  |> Stream.map(fn [[ll, lh], [rl, rh]] ->
    cond do
      # l contained by r
      ll in rl..rh && lh in rl..rh -> 1
      # r contained by l
      rl in ll..lh && rh in ll..lh -> 1
      true -> 0
    end
  end)
```

<!-- livebook:{"output":true} -->

```
#Stream<[
  enum: %File.Stream{
    path: "/Users/clark/code/aoc2022/inputs/4.txt",
    modes: [:raw, :read_ahead, :binary],
    line_or_bytes: :line,
    raw: true
  },
  funs: [#Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>,
   #Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>]
]>
```

```elixir
# Star 1
305 = Enum.sum(day4_star1)
```

<!-- livebook:{"output":true} -->

```
305
```

```elixir
day4_star2 =
  day4_input
  |> Stream.map(fn [[ll, lh], [rl, rh]] ->
    cond do
      # overlaps
      lh in rl..rh -> 1
      ll in rl..rh -> 1
      rl in ll..lh -> 1
      rh in ll..lh -> 1
      true -> 0
    end
  end)
```

<!-- livebook:{"output":true} -->

```
#Stream<[
  enum: %File.Stream{
    path: "/Users/clark/code/aoc2022/inputs/4.txt",
    modes: [:raw, :read_ahead, :binary],
    line_or_bytes: :line,
    raw: true
  },
  funs: [#Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>,
   #Function<48.124013645/1 in Stream.map/2>, #Function<48.124013645/1 in Stream.map/2>]
]>
```

```elixir
# Star 2
811 = Enum.sum(day4_star2)
```

<!-- livebook:{"output":true} -->

```
811
```

## Day 5

```elixir
day5_starting_state =
  "/Users/clark/code/aoc2022/inputs/5.txt"
  |> File.stream!()
  |> Stream.map(fn line ->
    String.trim(line)
  end)
  |> Stream.take_while(fn line ->
    !String.starts_with?(line, "1")
  end)
  |> Enum.map(fn line -> String.trim(line) end)

state_len = length(day5_starting_state)

day5_instructions =
  "/Users/clark/code/aoc2022/inputs/5.txt"
  |> File.stream!()
  |> Stream.drop(state_len + 2)
```

<!-- livebook:{"output":true} -->

```
#Stream<[
  enum: %File.Stream{
    path: "/Users/clark/code/aoc2022/inputs/5.txt",
    modes: [:raw, :read_ahead, :binary],
    line_or_bytes: :line,
    raw: true
  },
  funs: [#Function<34.124013645/1 in Stream.drop/2>]
]>
```

```elixir
byte_offsets =
  1
  |> Stream.iterate(fn i -> i + 4 end)
  |> Enum.take(9)

blank_state = Enum.map(1..9, fn i -> {i, []} end) |> Enum.into(%{})

day5_state =
  day5_starting_state
  |> Enum.reduce(blank_state, fn line, acc ->
    byte_offsets
    |> Enum.with_index()
    |> Enum.reduce(acc, fn {byte_offset, i}, acc ->
      Map.update!(acc, i + 1, fn stack ->
        box = String.at(line, byte_offset)

        if box == " " || is_nil(box) do
          stack
        else
          [box | stack]
        end
      end)
    end)
  end)
  |> Enum.map(fn {i, boxes} ->
    {i, Enum.reverse(boxes)}
  end)
  |> Enum.into(%{})
```

<!-- livebook:{"output":true} -->

```
%{
  1 => ["T", "R", "G", "W", "Q", "M", "F", "P"],
  2 => ["R", "F", "H"],
  3 => ["D", "S", "H", "G", "V", "R", "Z", "P"],
  4 => ["G", "W", "F", "B", "P", "H", "Q"],
  5 => ["H", "J", "M", "S", "P"],
  6 => ["L", "P", "R", "S", "H", "T", "Z", "M"],
  7 => ["L", "M", "N", "H", "T", "P"],
  8 => ["R", "Q", "D", "F"],
  9 => ["H", "P", "L", "N", "C", "S", "D"]
}
```

```elixir
# move 3 from 8 to 9
parser = ~r/move (?<move>\d+) from (?<from>\d+) to (?<to>\d+)/

interpretation_1 =
  day5_instructions
  |> Stream.map(fn instruction_line ->
    Regex.named_captures(parser, instruction_line)
  end)
  |> Enum.reduce(day5_state, fn %{"move" => move, "from" => from, "to" => to}, state ->
    {move, _} = Integer.parse(move)
    {from, _} = Integer.parse(from)
    {to, _} = Integer.parse(to)

    Enum.reduce(1..move, state, fn _, loop_state ->
      loop_state
      |> Map.update!(to, fn to_state ->
        [top | _] = Map.fetch!(loop_state, from)
        [top | to_state]
      end)
      |> Map.update!(from, fn from_state ->
        [_ | rest] = from_state
        rest
      end)
    end)
  end)
```

<!-- livebook:{"output":true} -->

```
%{
  1 => ["T", "M", "M", "Q", "R"],
  2 => ["P", "R", "S", "H"],
  3 => ["G", "P", "C", "D", "Z", "T"],
  4 => ["V", "F"],
  5 => ["Q"],
  6 => ["P", "L", "B", "H", "S", "H", "W", "F", "M", "R", "G", "S", "M", "N", "R", "G", "S", "P",
   "H", "P"],
  7 => ["F", "F"],
  8 => ["D", "P", "Q", "D", "J", "H", "N", "T", "L", "W", "Z", "L", "H", "P", "R"],
  9 => ["H"]
}
```

```elixir
# Star 1
"TPGVQPFDH" =
  1..9
  |> Enum.map(fn i ->
    [top | _] = Map.fetch!(interpretation_1, i)
    top
  end)
  |> Enum.join()
```

<!-- livebook:{"output":true} -->

```
"TPGVQPFDH"
```

```elixir
interpretation_2 =
  day5_instructions
  |> Stream.map(fn instruction_line ->
    Regex.named_captures(parser, instruction_line)
  end)
  |> Enum.reduce(day5_state, fn %{"move" => move, "from" => from, "to" => to}, state ->
    {move, _} = Integer.parse(move)
    {from, _} = Integer.parse(from)
    {to, _} = Integer.parse(to)

    state
    |> Map.update!(to, fn to_state ->
      the_move = Map.fetch!(state, from) |> Enum.take(move)
      the_move ++ to_state
    end)
    |> Map.update!(from, fn from_state ->
      Enum.drop(from_state, move)
    end)
  end)
```

<!-- livebook:{"output":true} -->

```
%{
  1 => ["D", "P", "J", "T", "V"],
  2 => ["M", "N", "H", "M"],
  3 => ["R", "Q", "F", "P", "T", "N"],
  4 => ["D", "Q"],
  5 => ["F"],
  6 => ["R", "H", "P", "R", "F", "R", "S", "Q", "D", "P", "P", "M", "G", "L", "L", "S", "W", "W",
   "Z", "B"],
  7 => ["H", "P"],
  8 => ["H", "S", "T", "M", "S", "R", "G", "P", "H", "G", "F", "H", "C", "L", "Z"],
  9 => ["H"]
}
```

```elixir
# Star 2
"DMRDFRHHH" =
  1..9
  |> Enum.map(fn i ->
    [top | _] = Map.fetch!(interpretation_2, i)
    top
  end)
  |> Enum.join()
```

<!-- livebook:{"output":true} -->

```
"DMRDFRHHH"
```
